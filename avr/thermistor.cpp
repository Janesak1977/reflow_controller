
#include "thermistor.h"
#include "ovencon.h"

#include <avr/interrupt.h> 
#include <avr/sleep.h> 

#include <avr/pgmspace.h>
#include <avr/io.h>




volatile uint16_t t_result;

uint16_t lookup(uint16_t x); // declared below
    
void thermistor_setup() {
    // AREF = AVcc
    ADMUX = (1<<REFS0);

    // ADC Enable and prescaler of 128
    // 16000000/128 = 125000
    ADCSRA = (1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
    
    
#ifdef ADC_SLEEP_READ    

    // enable interrupts
    ADCSRA |= (1<<ADIE); 
#endif
    
    
    DDRF&=~_BV(7);
    
    t_result=666;
}

    
    

uint16_t thermistor_read_adc() {
    uint8_t ch=THERMISTOR_CHANNEL;
    
    // select the corresponding channel 0~7
    // ANDing with '7' will always keep the value
    // of 'ch' between 0 and 7
    ch &= 0b00000111;  // AND operation with 7
    ADMUX = (ADMUX & 0xF8)|ch;     // clears the bottom 3 bits before ORing
    
    
    // not well tested and very slow.  Probably isn't needed as the accuracy doesn't increase that much.
#ifdef ADC_SLEEP_READ    
    set_sleep_mode(SLEEP_MODE_ADC); 
   
    sleep_enable();
    sei(); // make sure interrupts are enabled
    
    sleep_cpu(); // sleep should trigger ADC
    sleep_disable();
    
#else
    
    // start single convertion
    // write '1' to ADSC
    ADCSRA |= (1<<ADSC);
   
    
    // wait for conversion to complete
    // ADSC becomes '0' again
    // till then, run loop continuously

    while(ADCSRA & (1<<ADSC));
#endif
   
    return (ADC);    
}



// returns temp in 0.25C increments
uint16_t thermistor_read() {
    return lookup(thermistor_read_adc());
}



EMPTY_INTERRUPT(ADC_vect);




typedef struct {
 uint16_t k;
 uint8_t v;
} lut_bs_kvp;



/*generated by LUTGenerator:  Epcos Thermistor B57560G104F with 4.7k/2 high side divider.  Table is ADC to C/5 value.  Value is multiplied to C*4  by the LUT function */
static lut_bs_kvp lut_data[] PROGMEM = {
{46, 60}, {49, 59}, {53, 58}, {57, 57}, {61, 56}, {65, 55}, {70, 54}, {75, 53}, {80, 52}, {86, 51}, {93, 50}, {100, 49}, {108, 48}, {117, 47}, {126, 46}, {136, 45}, {147, 44}, {159, 43}, {172, 42}, {186, 41}, {201, 40}, {218, 39}, {235, 38}, {255, 37}, {275, 36}, {298, 35}, {321, 34}, {346, 33}, {373, 32}, {401, 31}, {431, 30}, {461, 29}, {493, 28}, {525, 27}, {559, 26}, {592, 25}, {626, 24}, {659, 23}, {692, 22}, {723, 21}, {754, 20}, {783, 19}, {811, 18}, {837, 17}, {860, 16}, {882, 15}, {902, 14}, {920, 13}, {935, 12}, {949, 11}, {961, 10}, {972, 9}, {981, 8}, {989, 7}, {995, 6}, {1000, 5}, {1005, 4}, {1009, 3}, {1012, 2}, {1014, 1}, {1016, 0}
};



#define LUT_READ_K(idx) (uint16_t) pgm_read_word(&lut_data[idx].k)
#define LUT_READ_V(idx) (uint8_t) pgm_read_byte(&lut_data[idx].v)

#define LOOKUP_ABS(x,y) (uint16_t)((x>=y) ? x-y : y-x )
#define LUT_LENGTH 61
#define LOOKUP_OUTPUT_SCALER 20


uint16_t lookup(uint16_t x){ 
    uint8_t low=0,
            high=LUT_LENGTH-1,            
            search_marker=(LUT_LENGTH-1)>>1;
    
    uint16_t k;    
    
    while (search_marker!=low && search_marker!=high){
        
        k=LUT_READ_K(search_marker);
        // exact match
        if (k==x){
            return LOOKUP_OUTPUT_SCALER *(uint16_t)LUT_READ_V(search_marker);            
        }
        
        if (k>x){
            high=search_marker;
            search_marker=high-((high-low)>>1)-1;    
        } else {
            low=search_marker;
            search_marker=low+((high-low)>>1)+1;    
        }
    }

    
    // check search marker one last time
    k=LUT_READ_K(search_marker);
    // exact match
    if (k==x){
            return LOOKUP_OUTPUT_SCALER*(uint16_t)LUT_READ_V(search_marker);            
    }

    
    // interpolate between high and low with fixed point math    
    // = l.v + (X-l.k) * (h.v-l.v)/(h.k-l.k)
    
    uint16_t lk=LUT_READ_K(low),
             hk=LUT_READ_K(high);    
    uint8_t lv=LUT_READ_V(low),
            hv=LUT_READ_V(high);
             
    
    uint16_t tb=LOOKUP_ABS(hk,lk); // temporarily store bottom in tb
    
    if (tb!=0){
        tb=(LOOKUP_OUTPUT_SCALER*LOOKUP_ABS(x,lk)* LOOKUP_ABS(hv,lv))/tb;        
    } else {
        tb=0;
    }
    
    bool negative=(lk>x) ^ (lv>hv) ^ (hk<lk);   
    //printf("neg %d\n",negative?1:0);
    
    if (negative){
        return (LOOKUP_OUTPUT_SCALER*(uint16_t)lv)-tb;
    } else {        
        return (LOOKUP_OUTPUT_SCALER*(uint16_t)lv)+tb;
    }
}
